// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/copa-europe-tokens/internal/tokens"
	"github.com/copa-europe-tokens/pkg/types"
)

type Operations struct {
	AddUserStub        func(*types.UserRecord) error
	addUserMutex       sync.RWMutex
	addUserArgsForCall []struct {
		arg1 *types.UserRecord
	}
	addUserReturns struct {
		result1 error
	}
	addUserReturnsOnCall map[int]struct {
		result1 error
	}
	DeployTokenTypeStub        func(*types.DeployRequest) (*types.DeployResponse, error)
	deployTokenTypeMutex       sync.RWMutex
	deployTokenTypeArgsForCall []struct {
		arg1 *types.DeployRequest
	}
	deployTokenTypeReturns struct {
		result1 *types.DeployResponse
		result2 error
	}
	deployTokenTypeReturnsOnCall map[int]struct {
		result1 *types.DeployResponse
		result2 error
	}
	GetAnnotationStub        func(string) (*types.AnnotationRecord, error)
	getAnnotationMutex       sync.RWMutex
	getAnnotationArgsForCall []struct {
		arg1 string
	}
	getAnnotationReturns struct {
		result1 *types.AnnotationRecord
		result2 error
	}
	getAnnotationReturnsOnCall map[int]struct {
		result1 *types.AnnotationRecord
		result2 error
	}
	GetAnnotationsByOwnerLinkStub        func(string, string, string) ([]*types.AnnotationRecord, error)
	getAnnotationsByOwnerLinkMutex       sync.RWMutex
	getAnnotationsByOwnerLinkArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	getAnnotationsByOwnerLinkReturns struct {
		result1 []*types.AnnotationRecord
		result2 error
	}
	getAnnotationsByOwnerLinkReturnsOnCall map[int]struct {
		result1 []*types.AnnotationRecord
		result2 error
	}
	GetStatusStub        func() (string, error)
	getStatusMutex       sync.RWMutex
	getStatusArgsForCall []struct {
	}
	getStatusReturns struct {
		result1 string
		result2 error
	}
	getStatusReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetTokenStub        func(string) (*types.TokenRecord, error)
	getTokenMutex       sync.RWMutex
	getTokenArgsForCall []struct {
		arg1 string
	}
	getTokenReturns struct {
		result1 *types.TokenRecord
		result2 error
	}
	getTokenReturnsOnCall map[int]struct {
		result1 *types.TokenRecord
		result2 error
	}
	GetTokenTypeStub        func(string) (*types.DeployResponse, error)
	getTokenTypeMutex       sync.RWMutex
	getTokenTypeArgsForCall []struct {
		arg1 string
	}
	getTokenTypeReturns struct {
		result1 *types.DeployResponse
		result2 error
	}
	getTokenTypeReturnsOnCall map[int]struct {
		result1 *types.DeployResponse
		result2 error
	}
	GetTokenTypesStub        func() ([]*types.DeployResponse, error)
	getTokenTypesMutex       sync.RWMutex
	getTokenTypesArgsForCall []struct {
	}
	getTokenTypesReturns struct {
		result1 []*types.DeployResponse
		result2 error
	}
	getTokenTypesReturnsOnCall map[int]struct {
		result1 []*types.DeployResponse
		result2 error
	}
	GetTokensByOwnerStub        func(string, string) ([]*types.TokenRecord, error)
	getTokensByOwnerMutex       sync.RWMutex
	getTokensByOwnerArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getTokensByOwnerReturns struct {
		result1 []*types.TokenRecord
		result2 error
	}
	getTokensByOwnerReturnsOnCall map[int]struct {
		result1 []*types.TokenRecord
		result2 error
	}
	GetUserStub        func(string) (*types.UserRecord, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 string
	}
	getUserReturns struct {
		result1 *types.UserRecord
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 *types.UserRecord
		result2 error
	}
	PrepareMintStub        func(string, *types.MintRequest) (*types.MintResponse, error)
	prepareMintMutex       sync.RWMutex
	prepareMintArgsForCall []struct {
		arg1 string
		arg2 *types.MintRequest
	}
	prepareMintReturns struct {
		result1 *types.MintResponse
		result2 error
	}
	prepareMintReturnsOnCall map[int]struct {
		result1 *types.MintResponse
		result2 error
	}
	PrepareRegisterStub        func(string, *types.AnnotationRegisterRequest) (*types.AnnotationRegisterResponse, error)
	prepareRegisterMutex       sync.RWMutex
	prepareRegisterArgsForCall []struct {
		arg1 string
		arg2 *types.AnnotationRegisterRequest
	}
	prepareRegisterReturns struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}
	prepareRegisterReturnsOnCall map[int]struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}
	PrepareTransferStub        func(string, *types.TransferRequest) (*types.TransferResponse, error)
	prepareTransferMutex       sync.RWMutex
	prepareTransferArgsForCall []struct {
		arg1 string
		arg2 *types.TransferRequest
	}
	prepareTransferReturns struct {
		result1 *types.TransferResponse
		result2 error
	}
	prepareTransferReturnsOnCall map[int]struct {
		result1 *types.TransferResponse
		result2 error
	}
	RemoveUserStub        func(string) error
	removeUserMutex       sync.RWMutex
	removeUserArgsForCall []struct {
		arg1 string
	}
	removeUserReturns struct {
		result1 error
	}
	removeUserReturnsOnCall map[int]struct {
		result1 error
	}
	SubmitTxStub        func(*types.SubmitRequest) (*types.SubmitResponse, error)
	submitTxMutex       sync.RWMutex
	submitTxArgsForCall []struct {
		arg1 *types.SubmitRequest
	}
	submitTxReturns struct {
		result1 *types.SubmitResponse
		result2 error
	}
	submitTxReturnsOnCall map[int]struct {
		result1 *types.SubmitResponse
		result2 error
	}
	UpdateUserStub        func(*types.UserRecord) error
	updateUserMutex       sync.RWMutex
	updateUserArgsForCall []struct {
		arg1 *types.UserRecord
	}
	updateUserReturns struct {
		result1 error
	}
	updateUserReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Operations) AddUser(arg1 *types.UserRecord) error {
	fake.addUserMutex.Lock()
	ret, specificReturn := fake.addUserReturnsOnCall[len(fake.addUserArgsForCall)]
	fake.addUserArgsForCall = append(fake.addUserArgsForCall, struct {
		arg1 *types.UserRecord
	}{arg1})
	fake.recordInvocation("AddUser", []interface{}{arg1})
	fake.addUserMutex.Unlock()
	if fake.AddUserStub != nil {
		return fake.AddUserStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addUserReturns
	return fakeReturns.result1
}

func (fake *Operations) AddUserCallCount() int {
	fake.addUserMutex.RLock()
	defer fake.addUserMutex.RUnlock()
	return len(fake.addUserArgsForCall)
}

func (fake *Operations) AddUserCalls(stub func(*types.UserRecord) error) {
	fake.addUserMutex.Lock()
	defer fake.addUserMutex.Unlock()
	fake.AddUserStub = stub
}

func (fake *Operations) AddUserArgsForCall(i int) *types.UserRecord {
	fake.addUserMutex.RLock()
	defer fake.addUserMutex.RUnlock()
	argsForCall := fake.addUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) AddUserReturns(result1 error) {
	fake.addUserMutex.Lock()
	defer fake.addUserMutex.Unlock()
	fake.AddUserStub = nil
	fake.addUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *Operations) AddUserReturnsOnCall(i int, result1 error) {
	fake.addUserMutex.Lock()
	defer fake.addUserMutex.Unlock()
	fake.AddUserStub = nil
	if fake.addUserReturnsOnCall == nil {
		fake.addUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Operations) DeployTokenType(arg1 *types.DeployRequest) (*types.DeployResponse, error) {
	fake.deployTokenTypeMutex.Lock()
	ret, specificReturn := fake.deployTokenTypeReturnsOnCall[len(fake.deployTokenTypeArgsForCall)]
	fake.deployTokenTypeArgsForCall = append(fake.deployTokenTypeArgsForCall, struct {
		arg1 *types.DeployRequest
	}{arg1})
	fake.recordInvocation("DeployTokenType", []interface{}{arg1})
	fake.deployTokenTypeMutex.Unlock()
	if fake.DeployTokenTypeStub != nil {
		return fake.DeployTokenTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deployTokenTypeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) DeployTokenTypeCallCount() int {
	fake.deployTokenTypeMutex.RLock()
	defer fake.deployTokenTypeMutex.RUnlock()
	return len(fake.deployTokenTypeArgsForCall)
}

func (fake *Operations) DeployTokenTypeCalls(stub func(*types.DeployRequest) (*types.DeployResponse, error)) {
	fake.deployTokenTypeMutex.Lock()
	defer fake.deployTokenTypeMutex.Unlock()
	fake.DeployTokenTypeStub = stub
}

func (fake *Operations) DeployTokenTypeArgsForCall(i int) *types.DeployRequest {
	fake.deployTokenTypeMutex.RLock()
	defer fake.deployTokenTypeMutex.RUnlock()
	argsForCall := fake.deployTokenTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) DeployTokenTypeReturns(result1 *types.DeployResponse, result2 error) {
	fake.deployTokenTypeMutex.Lock()
	defer fake.deployTokenTypeMutex.Unlock()
	fake.DeployTokenTypeStub = nil
	fake.deployTokenTypeReturns = struct {
		result1 *types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) DeployTokenTypeReturnsOnCall(i int, result1 *types.DeployResponse, result2 error) {
	fake.deployTokenTypeMutex.Lock()
	defer fake.deployTokenTypeMutex.Unlock()
	fake.DeployTokenTypeStub = nil
	if fake.deployTokenTypeReturnsOnCall == nil {
		fake.deployTokenTypeReturnsOnCall = make(map[int]struct {
			result1 *types.DeployResponse
			result2 error
		})
	}
	fake.deployTokenTypeReturnsOnCall[i] = struct {
		result1 *types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotation(arg1 string) (*types.AnnotationRecord, error) {
	fake.getAnnotationMutex.Lock()
	ret, specificReturn := fake.getAnnotationReturnsOnCall[len(fake.getAnnotationArgsForCall)]
	fake.getAnnotationArgsForCall = append(fake.getAnnotationArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetAnnotation", []interface{}{arg1})
	fake.getAnnotationMutex.Unlock()
	if fake.GetAnnotationStub != nil {
		return fake.GetAnnotationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAnnotationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetAnnotationCallCount() int {
	fake.getAnnotationMutex.RLock()
	defer fake.getAnnotationMutex.RUnlock()
	return len(fake.getAnnotationArgsForCall)
}

func (fake *Operations) GetAnnotationCalls(stub func(string) (*types.AnnotationRecord, error)) {
	fake.getAnnotationMutex.Lock()
	defer fake.getAnnotationMutex.Unlock()
	fake.GetAnnotationStub = stub
}

func (fake *Operations) GetAnnotationArgsForCall(i int) string {
	fake.getAnnotationMutex.RLock()
	defer fake.getAnnotationMutex.RUnlock()
	argsForCall := fake.getAnnotationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetAnnotationReturns(result1 *types.AnnotationRecord, result2 error) {
	fake.getAnnotationMutex.Lock()
	defer fake.getAnnotationMutex.Unlock()
	fake.GetAnnotationStub = nil
	fake.getAnnotationReturns = struct {
		result1 *types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotationReturnsOnCall(i int, result1 *types.AnnotationRecord, result2 error) {
	fake.getAnnotationMutex.Lock()
	defer fake.getAnnotationMutex.Unlock()
	fake.GetAnnotationStub = nil
	if fake.getAnnotationReturnsOnCall == nil {
		fake.getAnnotationReturnsOnCall = make(map[int]struct {
			result1 *types.AnnotationRecord
			result2 error
		})
	}
	fake.getAnnotationReturnsOnCall[i] = struct {
		result1 *types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotationsByOwnerLink(arg1 string, arg2 string, arg3 string) ([]*types.AnnotationRecord, error) {
	fake.getAnnotationsByOwnerLinkMutex.Lock()
	ret, specificReturn := fake.getAnnotationsByOwnerLinkReturnsOnCall[len(fake.getAnnotationsByOwnerLinkArgsForCall)]
	fake.getAnnotationsByOwnerLinkArgsForCall = append(fake.getAnnotationsByOwnerLinkArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetAnnotationsByOwnerLink", []interface{}{arg1, arg2, arg3})
	fake.getAnnotationsByOwnerLinkMutex.Unlock()
	if fake.GetAnnotationsByOwnerLinkStub != nil {
		return fake.GetAnnotationsByOwnerLinkStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAnnotationsByOwnerLinkReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetAnnotationsByOwnerLinkCallCount() int {
	fake.getAnnotationsByOwnerLinkMutex.RLock()
	defer fake.getAnnotationsByOwnerLinkMutex.RUnlock()
	return len(fake.getAnnotationsByOwnerLinkArgsForCall)
}

func (fake *Operations) GetAnnotationsByOwnerLinkCalls(stub func(string, string, string) ([]*types.AnnotationRecord, error)) {
	fake.getAnnotationsByOwnerLinkMutex.Lock()
	defer fake.getAnnotationsByOwnerLinkMutex.Unlock()
	fake.GetAnnotationsByOwnerLinkStub = stub
}

func (fake *Operations) GetAnnotationsByOwnerLinkArgsForCall(i int) (string, string, string) {
	fake.getAnnotationsByOwnerLinkMutex.RLock()
	defer fake.getAnnotationsByOwnerLinkMutex.RUnlock()
	argsForCall := fake.getAnnotationsByOwnerLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Operations) GetAnnotationsByOwnerLinkReturns(result1 []*types.AnnotationRecord, result2 error) {
	fake.getAnnotationsByOwnerLinkMutex.Lock()
	defer fake.getAnnotationsByOwnerLinkMutex.Unlock()
	fake.GetAnnotationsByOwnerLinkStub = nil
	fake.getAnnotationsByOwnerLinkReturns = struct {
		result1 []*types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotationsByOwnerLinkReturnsOnCall(i int, result1 []*types.AnnotationRecord, result2 error) {
	fake.getAnnotationsByOwnerLinkMutex.Lock()
	defer fake.getAnnotationsByOwnerLinkMutex.Unlock()
	fake.GetAnnotationsByOwnerLinkStub = nil
	if fake.getAnnotationsByOwnerLinkReturnsOnCall == nil {
		fake.getAnnotationsByOwnerLinkReturnsOnCall = make(map[int]struct {
			result1 []*types.AnnotationRecord
			result2 error
		})
	}
	fake.getAnnotationsByOwnerLinkReturnsOnCall[i] = struct {
		result1 []*types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetStatus() (string, error) {
	fake.getStatusMutex.Lock()
	ret, specificReturn := fake.getStatusReturnsOnCall[len(fake.getStatusArgsForCall)]
	fake.getStatusArgsForCall = append(fake.getStatusArgsForCall, struct {
	}{})
	fake.recordInvocation("GetStatus", []interface{}{})
	fake.getStatusMutex.Unlock()
	if fake.GetStatusStub != nil {
		return fake.GetStatusStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetStatusCallCount() int {
	fake.getStatusMutex.RLock()
	defer fake.getStatusMutex.RUnlock()
	return len(fake.getStatusArgsForCall)
}

func (fake *Operations) GetStatusCalls(stub func() (string, error)) {
	fake.getStatusMutex.Lock()
	defer fake.getStatusMutex.Unlock()
	fake.GetStatusStub = stub
}

func (fake *Operations) GetStatusReturns(result1 string, result2 error) {
	fake.getStatusMutex.Lock()
	defer fake.getStatusMutex.Unlock()
	fake.GetStatusStub = nil
	fake.getStatusReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetStatusReturnsOnCall(i int, result1 string, result2 error) {
	fake.getStatusMutex.Lock()
	defer fake.getStatusMutex.Unlock()
	fake.GetStatusStub = nil
	if fake.getStatusReturnsOnCall == nil {
		fake.getStatusReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStatusReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetToken(arg1 string) (*types.TokenRecord, error) {
	fake.getTokenMutex.Lock()
	ret, specificReturn := fake.getTokenReturnsOnCall[len(fake.getTokenArgsForCall)]
	fake.getTokenArgsForCall = append(fake.getTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetToken", []interface{}{arg1})
	fake.getTokenMutex.Unlock()
	if fake.GetTokenStub != nil {
		return fake.GetTokenStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokenCallCount() int {
	fake.getTokenMutex.RLock()
	defer fake.getTokenMutex.RUnlock()
	return len(fake.getTokenArgsForCall)
}

func (fake *Operations) GetTokenCalls(stub func(string) (*types.TokenRecord, error)) {
	fake.getTokenMutex.Lock()
	defer fake.getTokenMutex.Unlock()
	fake.GetTokenStub = stub
}

func (fake *Operations) GetTokenArgsForCall(i int) string {
	fake.getTokenMutex.RLock()
	defer fake.getTokenMutex.RUnlock()
	argsForCall := fake.getTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetTokenReturns(result1 *types.TokenRecord, result2 error) {
	fake.getTokenMutex.Lock()
	defer fake.getTokenMutex.Unlock()
	fake.GetTokenStub = nil
	fake.getTokenReturns = struct {
		result1 *types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenReturnsOnCall(i int, result1 *types.TokenRecord, result2 error) {
	fake.getTokenMutex.Lock()
	defer fake.getTokenMutex.Unlock()
	fake.GetTokenStub = nil
	if fake.getTokenReturnsOnCall == nil {
		fake.getTokenReturnsOnCall = make(map[int]struct {
			result1 *types.TokenRecord
			result2 error
		})
	}
	fake.getTokenReturnsOnCall[i] = struct {
		result1 *types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenType(arg1 string) (*types.DeployResponse, error) {
	fake.getTokenTypeMutex.Lock()
	ret, specificReturn := fake.getTokenTypeReturnsOnCall[len(fake.getTokenTypeArgsForCall)]
	fake.getTokenTypeArgsForCall = append(fake.getTokenTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetTokenType", []interface{}{arg1})
	fake.getTokenTypeMutex.Unlock()
	if fake.GetTokenTypeStub != nil {
		return fake.GetTokenTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTokenTypeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokenTypeCallCount() int {
	fake.getTokenTypeMutex.RLock()
	defer fake.getTokenTypeMutex.RUnlock()
	return len(fake.getTokenTypeArgsForCall)
}

func (fake *Operations) GetTokenTypeCalls(stub func(string) (*types.DeployResponse, error)) {
	fake.getTokenTypeMutex.Lock()
	defer fake.getTokenTypeMutex.Unlock()
	fake.GetTokenTypeStub = stub
}

func (fake *Operations) GetTokenTypeArgsForCall(i int) string {
	fake.getTokenTypeMutex.RLock()
	defer fake.getTokenTypeMutex.RUnlock()
	argsForCall := fake.getTokenTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetTokenTypeReturns(result1 *types.DeployResponse, result2 error) {
	fake.getTokenTypeMutex.Lock()
	defer fake.getTokenTypeMutex.Unlock()
	fake.GetTokenTypeStub = nil
	fake.getTokenTypeReturns = struct {
		result1 *types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenTypeReturnsOnCall(i int, result1 *types.DeployResponse, result2 error) {
	fake.getTokenTypeMutex.Lock()
	defer fake.getTokenTypeMutex.Unlock()
	fake.GetTokenTypeStub = nil
	if fake.getTokenTypeReturnsOnCall == nil {
		fake.getTokenTypeReturnsOnCall = make(map[int]struct {
			result1 *types.DeployResponse
			result2 error
		})
	}
	fake.getTokenTypeReturnsOnCall[i] = struct {
		result1 *types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenTypes() ([]*types.DeployResponse, error) {
	fake.getTokenTypesMutex.Lock()
	ret, specificReturn := fake.getTokenTypesReturnsOnCall[len(fake.getTokenTypesArgsForCall)]
	fake.getTokenTypesArgsForCall = append(fake.getTokenTypesArgsForCall, struct {
	}{})
	fake.recordInvocation("GetTokenTypes", []interface{}{})
	fake.getTokenTypesMutex.Unlock()
	if fake.GetTokenTypesStub != nil {
		return fake.GetTokenTypesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTokenTypesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokenTypesCallCount() int {
	fake.getTokenTypesMutex.RLock()
	defer fake.getTokenTypesMutex.RUnlock()
	return len(fake.getTokenTypesArgsForCall)
}

func (fake *Operations) GetTokenTypesCalls(stub func() ([]*types.DeployResponse, error)) {
	fake.getTokenTypesMutex.Lock()
	defer fake.getTokenTypesMutex.Unlock()
	fake.GetTokenTypesStub = stub
}

func (fake *Operations) GetTokenTypesReturns(result1 []*types.DeployResponse, result2 error) {
	fake.getTokenTypesMutex.Lock()
	defer fake.getTokenTypesMutex.Unlock()
	fake.GetTokenTypesStub = nil
	fake.getTokenTypesReturns = struct {
		result1 []*types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenTypesReturnsOnCall(i int, result1 []*types.DeployResponse, result2 error) {
	fake.getTokenTypesMutex.Lock()
	defer fake.getTokenTypesMutex.Unlock()
	fake.GetTokenTypesStub = nil
	if fake.getTokenTypesReturnsOnCall == nil {
		fake.getTokenTypesReturnsOnCall = make(map[int]struct {
			result1 []*types.DeployResponse
			result2 error
		})
	}
	fake.getTokenTypesReturnsOnCall[i] = struct {
		result1 []*types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokensByOwner(arg1 string, arg2 string) ([]*types.TokenRecord, error) {
	fake.getTokensByOwnerMutex.Lock()
	ret, specificReturn := fake.getTokensByOwnerReturnsOnCall[len(fake.getTokensByOwnerArgsForCall)]
	fake.getTokensByOwnerArgsForCall = append(fake.getTokensByOwnerArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetTokensByOwner", []interface{}{arg1, arg2})
	fake.getTokensByOwnerMutex.Unlock()
	if fake.GetTokensByOwnerStub != nil {
		return fake.GetTokensByOwnerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTokensByOwnerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokensByOwnerCallCount() int {
	fake.getTokensByOwnerMutex.RLock()
	defer fake.getTokensByOwnerMutex.RUnlock()
	return len(fake.getTokensByOwnerArgsForCall)
}

func (fake *Operations) GetTokensByOwnerCalls(stub func(string, string) ([]*types.TokenRecord, error)) {
	fake.getTokensByOwnerMutex.Lock()
	defer fake.getTokensByOwnerMutex.Unlock()
	fake.GetTokensByOwnerStub = stub
}

func (fake *Operations) GetTokensByOwnerArgsForCall(i int) (string, string) {
	fake.getTokensByOwnerMutex.RLock()
	defer fake.getTokensByOwnerMutex.RUnlock()
	argsForCall := fake.getTokensByOwnerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) GetTokensByOwnerReturns(result1 []*types.TokenRecord, result2 error) {
	fake.getTokensByOwnerMutex.Lock()
	defer fake.getTokensByOwnerMutex.Unlock()
	fake.GetTokensByOwnerStub = nil
	fake.getTokensByOwnerReturns = struct {
		result1 []*types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokensByOwnerReturnsOnCall(i int, result1 []*types.TokenRecord, result2 error) {
	fake.getTokensByOwnerMutex.Lock()
	defer fake.getTokensByOwnerMutex.Unlock()
	fake.GetTokensByOwnerStub = nil
	if fake.getTokensByOwnerReturnsOnCall == nil {
		fake.getTokensByOwnerReturnsOnCall = make(map[int]struct {
			result1 []*types.TokenRecord
			result2 error
		})
	}
	fake.getTokensByOwnerReturnsOnCall[i] = struct {
		result1 []*types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetUser(arg1 string) (*types.UserRecord, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetUser", []interface{}{arg1})
	fake.getUserMutex.Unlock()
	if fake.GetUserStub != nil {
		return fake.GetUserStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getUserReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *Operations) GetUserCalls(stub func(string) (*types.UserRecord, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *Operations) GetUserArgsForCall(i int) string {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetUserReturns(result1 *types.UserRecord, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 *types.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetUserReturnsOnCall(i int, result1 *types.UserRecord, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 *types.UserRecord
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 *types.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareMint(arg1 string, arg2 *types.MintRequest) (*types.MintResponse, error) {
	fake.prepareMintMutex.Lock()
	ret, specificReturn := fake.prepareMintReturnsOnCall[len(fake.prepareMintArgsForCall)]
	fake.prepareMintArgsForCall = append(fake.prepareMintArgsForCall, struct {
		arg1 string
		arg2 *types.MintRequest
	}{arg1, arg2})
	fake.recordInvocation("PrepareMint", []interface{}{arg1, arg2})
	fake.prepareMintMutex.Unlock()
	if fake.PrepareMintStub != nil {
		return fake.PrepareMintStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.prepareMintReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareMintCallCount() int {
	fake.prepareMintMutex.RLock()
	defer fake.prepareMintMutex.RUnlock()
	return len(fake.prepareMintArgsForCall)
}

func (fake *Operations) PrepareMintCalls(stub func(string, *types.MintRequest) (*types.MintResponse, error)) {
	fake.prepareMintMutex.Lock()
	defer fake.prepareMintMutex.Unlock()
	fake.PrepareMintStub = stub
}

func (fake *Operations) PrepareMintArgsForCall(i int) (string, *types.MintRequest) {
	fake.prepareMintMutex.RLock()
	defer fake.prepareMintMutex.RUnlock()
	argsForCall := fake.prepareMintArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareMintReturns(result1 *types.MintResponse, result2 error) {
	fake.prepareMintMutex.Lock()
	defer fake.prepareMintMutex.Unlock()
	fake.PrepareMintStub = nil
	fake.prepareMintReturns = struct {
		result1 *types.MintResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareMintReturnsOnCall(i int, result1 *types.MintResponse, result2 error) {
	fake.prepareMintMutex.Lock()
	defer fake.prepareMintMutex.Unlock()
	fake.PrepareMintStub = nil
	if fake.prepareMintReturnsOnCall == nil {
		fake.prepareMintReturnsOnCall = make(map[int]struct {
			result1 *types.MintResponse
			result2 error
		})
	}
	fake.prepareMintReturnsOnCall[i] = struct {
		result1 *types.MintResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareRegister(arg1 string, arg2 *types.AnnotationRegisterRequest) (*types.AnnotationRegisterResponse, error) {
	fake.prepareRegisterMutex.Lock()
	ret, specificReturn := fake.prepareRegisterReturnsOnCall[len(fake.prepareRegisterArgsForCall)]
	fake.prepareRegisterArgsForCall = append(fake.prepareRegisterArgsForCall, struct {
		arg1 string
		arg2 *types.AnnotationRegisterRequest
	}{arg1, arg2})
	fake.recordInvocation("PrepareRegister", []interface{}{arg1, arg2})
	fake.prepareRegisterMutex.Unlock()
	if fake.PrepareRegisterStub != nil {
		return fake.PrepareRegisterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.prepareRegisterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareRegisterCallCount() int {
	fake.prepareRegisterMutex.RLock()
	defer fake.prepareRegisterMutex.RUnlock()
	return len(fake.prepareRegisterArgsForCall)
}

func (fake *Operations) PrepareRegisterCalls(stub func(string, *types.AnnotationRegisterRequest) (*types.AnnotationRegisterResponse, error)) {
	fake.prepareRegisterMutex.Lock()
	defer fake.prepareRegisterMutex.Unlock()
	fake.PrepareRegisterStub = stub
}

func (fake *Operations) PrepareRegisterArgsForCall(i int) (string, *types.AnnotationRegisterRequest) {
	fake.prepareRegisterMutex.RLock()
	defer fake.prepareRegisterMutex.RUnlock()
	argsForCall := fake.prepareRegisterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareRegisterReturns(result1 *types.AnnotationRegisterResponse, result2 error) {
	fake.prepareRegisterMutex.Lock()
	defer fake.prepareRegisterMutex.Unlock()
	fake.PrepareRegisterStub = nil
	fake.prepareRegisterReturns = struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareRegisterReturnsOnCall(i int, result1 *types.AnnotationRegisterResponse, result2 error) {
	fake.prepareRegisterMutex.Lock()
	defer fake.prepareRegisterMutex.Unlock()
	fake.PrepareRegisterStub = nil
	if fake.prepareRegisterReturnsOnCall == nil {
		fake.prepareRegisterReturnsOnCall = make(map[int]struct {
			result1 *types.AnnotationRegisterResponse
			result2 error
		})
	}
	fake.prepareRegisterReturnsOnCall[i] = struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareTransfer(arg1 string, arg2 *types.TransferRequest) (*types.TransferResponse, error) {
	fake.prepareTransferMutex.Lock()
	ret, specificReturn := fake.prepareTransferReturnsOnCall[len(fake.prepareTransferArgsForCall)]
	fake.prepareTransferArgsForCall = append(fake.prepareTransferArgsForCall, struct {
		arg1 string
		arg2 *types.TransferRequest
	}{arg1, arg2})
	fake.recordInvocation("PrepareTransfer", []interface{}{arg1, arg2})
	fake.prepareTransferMutex.Unlock()
	if fake.PrepareTransferStub != nil {
		return fake.PrepareTransferStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.prepareTransferReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareTransferCallCount() int {
	fake.prepareTransferMutex.RLock()
	defer fake.prepareTransferMutex.RUnlock()
	return len(fake.prepareTransferArgsForCall)
}

func (fake *Operations) PrepareTransferCalls(stub func(string, *types.TransferRequest) (*types.TransferResponse, error)) {
	fake.prepareTransferMutex.Lock()
	defer fake.prepareTransferMutex.Unlock()
	fake.PrepareTransferStub = stub
}

func (fake *Operations) PrepareTransferArgsForCall(i int) (string, *types.TransferRequest) {
	fake.prepareTransferMutex.RLock()
	defer fake.prepareTransferMutex.RUnlock()
	argsForCall := fake.prepareTransferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareTransferReturns(result1 *types.TransferResponse, result2 error) {
	fake.prepareTransferMutex.Lock()
	defer fake.prepareTransferMutex.Unlock()
	fake.PrepareTransferStub = nil
	fake.prepareTransferReturns = struct {
		result1 *types.TransferResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareTransferReturnsOnCall(i int, result1 *types.TransferResponse, result2 error) {
	fake.prepareTransferMutex.Lock()
	defer fake.prepareTransferMutex.Unlock()
	fake.PrepareTransferStub = nil
	if fake.prepareTransferReturnsOnCall == nil {
		fake.prepareTransferReturnsOnCall = make(map[int]struct {
			result1 *types.TransferResponse
			result2 error
		})
	}
	fake.prepareTransferReturnsOnCall[i] = struct {
		result1 *types.TransferResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) RemoveUser(arg1 string) error {
	fake.removeUserMutex.Lock()
	ret, specificReturn := fake.removeUserReturnsOnCall[len(fake.removeUserArgsForCall)]
	fake.removeUserArgsForCall = append(fake.removeUserArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemoveUser", []interface{}{arg1})
	fake.removeUserMutex.Unlock()
	if fake.RemoveUserStub != nil {
		return fake.RemoveUserStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeUserReturns
	return fakeReturns.result1
}

func (fake *Operations) RemoveUserCallCount() int {
	fake.removeUserMutex.RLock()
	defer fake.removeUserMutex.RUnlock()
	return len(fake.removeUserArgsForCall)
}

func (fake *Operations) RemoveUserCalls(stub func(string) error) {
	fake.removeUserMutex.Lock()
	defer fake.removeUserMutex.Unlock()
	fake.RemoveUserStub = stub
}

func (fake *Operations) RemoveUserArgsForCall(i int) string {
	fake.removeUserMutex.RLock()
	defer fake.removeUserMutex.RUnlock()
	argsForCall := fake.removeUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) RemoveUserReturns(result1 error) {
	fake.removeUserMutex.Lock()
	defer fake.removeUserMutex.Unlock()
	fake.RemoveUserStub = nil
	fake.removeUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *Operations) RemoveUserReturnsOnCall(i int, result1 error) {
	fake.removeUserMutex.Lock()
	defer fake.removeUserMutex.Unlock()
	fake.RemoveUserStub = nil
	if fake.removeUserReturnsOnCall == nil {
		fake.removeUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Operations) SubmitTx(arg1 *types.SubmitRequest) (*types.SubmitResponse, error) {
	fake.submitTxMutex.Lock()
	ret, specificReturn := fake.submitTxReturnsOnCall[len(fake.submitTxArgsForCall)]
	fake.submitTxArgsForCall = append(fake.submitTxArgsForCall, struct {
		arg1 *types.SubmitRequest
	}{arg1})
	fake.recordInvocation("SubmitTx", []interface{}{arg1})
	fake.submitTxMutex.Unlock()
	if fake.SubmitTxStub != nil {
		return fake.SubmitTxStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.submitTxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) SubmitTxCallCount() int {
	fake.submitTxMutex.RLock()
	defer fake.submitTxMutex.RUnlock()
	return len(fake.submitTxArgsForCall)
}

func (fake *Operations) SubmitTxCalls(stub func(*types.SubmitRequest) (*types.SubmitResponse, error)) {
	fake.submitTxMutex.Lock()
	defer fake.submitTxMutex.Unlock()
	fake.SubmitTxStub = stub
}

func (fake *Operations) SubmitTxArgsForCall(i int) *types.SubmitRequest {
	fake.submitTxMutex.RLock()
	defer fake.submitTxMutex.RUnlock()
	argsForCall := fake.submitTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) SubmitTxReturns(result1 *types.SubmitResponse, result2 error) {
	fake.submitTxMutex.Lock()
	defer fake.submitTxMutex.Unlock()
	fake.SubmitTxStub = nil
	fake.submitTxReturns = struct {
		result1 *types.SubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) SubmitTxReturnsOnCall(i int, result1 *types.SubmitResponse, result2 error) {
	fake.submitTxMutex.Lock()
	defer fake.submitTxMutex.Unlock()
	fake.SubmitTxStub = nil
	if fake.submitTxReturnsOnCall == nil {
		fake.submitTxReturnsOnCall = make(map[int]struct {
			result1 *types.SubmitResponse
			result2 error
		})
	}
	fake.submitTxReturnsOnCall[i] = struct {
		result1 *types.SubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) UpdateUser(arg1 *types.UserRecord) error {
	fake.updateUserMutex.Lock()
	ret, specificReturn := fake.updateUserReturnsOnCall[len(fake.updateUserArgsForCall)]
	fake.updateUserArgsForCall = append(fake.updateUserArgsForCall, struct {
		arg1 *types.UserRecord
	}{arg1})
	fake.recordInvocation("UpdateUser", []interface{}{arg1})
	fake.updateUserMutex.Unlock()
	if fake.UpdateUserStub != nil {
		return fake.UpdateUserStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateUserReturns
	return fakeReturns.result1
}

func (fake *Operations) UpdateUserCallCount() int {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	return len(fake.updateUserArgsForCall)
}

func (fake *Operations) UpdateUserCalls(stub func(*types.UserRecord) error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = stub
}

func (fake *Operations) UpdateUserArgsForCall(i int) *types.UserRecord {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	argsForCall := fake.updateUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) UpdateUserReturns(result1 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	fake.updateUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *Operations) UpdateUserReturnsOnCall(i int, result1 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	if fake.updateUserReturnsOnCall == nil {
		fake.updateUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Operations) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addUserMutex.RLock()
	defer fake.addUserMutex.RUnlock()
	fake.deployTokenTypeMutex.RLock()
	defer fake.deployTokenTypeMutex.RUnlock()
	fake.getAnnotationMutex.RLock()
	defer fake.getAnnotationMutex.RUnlock()
	fake.getAnnotationsByOwnerLinkMutex.RLock()
	defer fake.getAnnotationsByOwnerLinkMutex.RUnlock()
	fake.getStatusMutex.RLock()
	defer fake.getStatusMutex.RUnlock()
	fake.getTokenMutex.RLock()
	defer fake.getTokenMutex.RUnlock()
	fake.getTokenTypeMutex.RLock()
	defer fake.getTokenTypeMutex.RUnlock()
	fake.getTokenTypesMutex.RLock()
	defer fake.getTokenTypesMutex.RUnlock()
	fake.getTokensByOwnerMutex.RLock()
	defer fake.getTokensByOwnerMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.prepareMintMutex.RLock()
	defer fake.prepareMintMutex.RUnlock()
	fake.prepareRegisterMutex.RLock()
	defer fake.prepareRegisterMutex.RUnlock()
	fake.prepareTransferMutex.RLock()
	defer fake.prepareTransferMutex.RUnlock()
	fake.removeUserMutex.RLock()
	defer fake.removeUserMutex.RUnlock()
	fake.submitTxMutex.RLock()
	defer fake.submitTxMutex.RUnlock()
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Operations) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tokens.Operations = new(Operations)
