// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/copa-europe-tokens/internal/tokens"
	"github.com/copa-europe-tokens/pkg/types"
)

type Operations struct {
	AddUserStub        func(*types.UserRecord) error
	addUserMutex       sync.RWMutex
	addUserArgsForCall []struct {
		arg1 *types.UserRecord
	}
	addUserReturns struct {
		result1 error
	}
	addUserReturnsOnCall map[int]struct {
		result1 error
	}
	DeployTokenTypeStub        func(*types.DeployRequest) (*types.DeployResponse, error)
	deployTokenTypeMutex       sync.RWMutex
	deployTokenTypeArgsForCall []struct {
		arg1 *types.DeployRequest
	}
	deployTokenTypeReturns struct {
		result1 *types.DeployResponse
		result2 error
	}
	deployTokenTypeReturnsOnCall map[int]struct {
		result1 *types.DeployResponse
		result2 error
	}
	FungibleAccountsStub        func(string, string, string) ([]types.FungibleAccountRecord, error)
	fungibleAccountsMutex       sync.RWMutex
	fungibleAccountsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	fungibleAccountsReturns struct {
		result1 []types.FungibleAccountRecord
		result2 error
	}
	fungibleAccountsReturnsOnCall map[int]struct {
		result1 []types.FungibleAccountRecord
		result2 error
	}
	FungibleDeployStub        func(*types.FungibleDeployRequest) (*types.FungibleDeployResponse, error)
	fungibleDeployMutex       sync.RWMutex
	fungibleDeployArgsForCall []struct {
		arg1 *types.FungibleDeployRequest
	}
	fungibleDeployReturns struct {
		result1 *types.FungibleDeployResponse
		result2 error
	}
	fungibleDeployReturnsOnCall map[int]struct {
		result1 *types.FungibleDeployResponse
		result2 error
	}
	FungibleDescribeStub        func(string) (*types.FungibleDescribeResponse, error)
	fungibleDescribeMutex       sync.RWMutex
	fungibleDescribeArgsForCall []struct {
		arg1 string
	}
	fungibleDescribeReturns struct {
		result1 *types.FungibleDescribeResponse
		result2 error
	}
	fungibleDescribeReturnsOnCall map[int]struct {
		result1 *types.FungibleDescribeResponse
		result2 error
	}
	FungiblePrepareConsolidateStub        func(string, *types.FungibleConsolidateRequest) (*types.FungibleConsolidateResponse, error)
	fungiblePrepareConsolidateMutex       sync.RWMutex
	fungiblePrepareConsolidateArgsForCall []struct {
		arg1 string
		arg2 *types.FungibleConsolidateRequest
	}
	fungiblePrepareConsolidateReturns struct {
		result1 *types.FungibleConsolidateResponse
		result2 error
	}
	fungiblePrepareConsolidateReturnsOnCall map[int]struct {
		result1 *types.FungibleConsolidateResponse
		result2 error
	}
	FungiblePrepareMintStub        func(string, *types.FungibleMintRequest) (*types.FungibleMintResponse, error)
	fungiblePrepareMintMutex       sync.RWMutex
	fungiblePrepareMintArgsForCall []struct {
		arg1 string
		arg2 *types.FungibleMintRequest
	}
	fungiblePrepareMintReturns struct {
		result1 *types.FungibleMintResponse
		result2 error
	}
	fungiblePrepareMintReturnsOnCall map[int]struct {
		result1 *types.FungibleMintResponse
		result2 error
	}
	FungiblePrepareTransferStub        func(string, *types.FungibleTransferRequest) (*types.FungibleTransferResponse, error)
	fungiblePrepareTransferMutex       sync.RWMutex
	fungiblePrepareTransferArgsForCall []struct {
		arg1 string
		arg2 *types.FungibleTransferRequest
	}
	fungiblePrepareTransferReturns struct {
		result1 *types.FungibleTransferResponse
		result2 error
	}
	fungiblePrepareTransferReturnsOnCall map[int]struct {
		result1 *types.FungibleTransferResponse
		result2 error
	}
	FungibleSubmitTxStub        func(*types.FungibleSubmitRequest) (*types.FungibleSubmitResponse, error)
	fungibleSubmitTxMutex       sync.RWMutex
	fungibleSubmitTxArgsForCall []struct {
		arg1 *types.FungibleSubmitRequest
	}
	fungibleSubmitTxReturns struct {
		result1 *types.FungibleSubmitResponse
		result2 error
	}
	fungibleSubmitTxReturnsOnCall map[int]struct {
		result1 *types.FungibleSubmitResponse
		result2 error
	}
	GetAnnotationStub        func(string) (*types.AnnotationRecord, error)
	getAnnotationMutex       sync.RWMutex
	getAnnotationArgsForCall []struct {
		arg1 string
	}
	getAnnotationReturns struct {
		result1 *types.AnnotationRecord
		result2 error
	}
	getAnnotationReturnsOnCall map[int]struct {
		result1 *types.AnnotationRecord
		result2 error
	}
	GetAnnotationsByFilterStub        func(string, string, string, string) ([]*types.AnnotationRecord, error)
	getAnnotationsByFilterMutex       sync.RWMutex
	getAnnotationsByFilterArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	getAnnotationsByFilterReturns struct {
		result1 []*types.AnnotationRecord
		result2 error
	}
	getAnnotationsByFilterReturnsOnCall map[int]struct {
		result1 []*types.AnnotationRecord
		result2 error
	}
	GetStatusStub        func() (string, error)
	getStatusMutex       sync.RWMutex
	getStatusArgsForCall []struct {
	}
	getStatusReturns struct {
		result1 string
		result2 error
	}
	getStatusReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetTokenStub        func(string) (*types.TokenRecord, error)
	getTokenMutex       sync.RWMutex
	getTokenArgsForCall []struct {
		arg1 string
	}
	getTokenReturns struct {
		result1 *types.TokenRecord
		result2 error
	}
	getTokenReturnsOnCall map[int]struct {
		result1 *types.TokenRecord
		result2 error
	}
	GetTokenTypeStub        func(string) (*types.TokenDescription, error)
	getTokenTypeMutex       sync.RWMutex
	getTokenTypeArgsForCall []struct {
		arg1 string
	}
	getTokenTypeReturns struct {
		result1 *types.TokenDescription
		result2 error
	}
	getTokenTypeReturnsOnCall map[int]struct {
		result1 *types.TokenDescription
		result2 error
	}
	GetTokenTypesStub        func() ([]*types.TokenDescription, error)
	getTokenTypesMutex       sync.RWMutex
	getTokenTypesArgsForCall []struct {
	}
	getTokenTypesReturns struct {
		result1 []*types.TokenDescription
		result2 error
	}
	getTokenTypesReturnsOnCall map[int]struct {
		result1 []*types.TokenDescription
		result2 error
	}
	GetTokensByFilterStub        func(string, string, string, string) ([]*types.TokenRecord, error)
	getTokensByFilterMutex       sync.RWMutex
	getTokensByFilterArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	getTokensByFilterReturns struct {
		result1 []*types.TokenRecord
		result2 error
	}
	getTokensByFilterReturnsOnCall map[int]struct {
		result1 []*types.TokenRecord
		result2 error
	}
	GetUserStub        func(string) (*types.UserRecord, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 string
	}
	getUserReturns struct {
		result1 *types.UserRecord
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 *types.UserRecord
		result2 error
	}
	PrepareMintStub        func(string, *types.MintRequest) (*types.MintResponse, error)
	prepareMintMutex       sync.RWMutex
	prepareMintArgsForCall []struct {
		arg1 string
		arg2 *types.MintRequest
	}
	prepareMintReturns struct {
		result1 *types.MintResponse
		result2 error
	}
	prepareMintReturnsOnCall map[int]struct {
		result1 *types.MintResponse
		result2 error
	}
	PrepareRegisterStub        func(string, *types.AnnotationRegisterRequest) (*types.AnnotationRegisterResponse, error)
	prepareRegisterMutex       sync.RWMutex
	prepareRegisterArgsForCall []struct {
		arg1 string
		arg2 *types.AnnotationRegisterRequest
	}
	prepareRegisterReturns struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}
	prepareRegisterReturnsOnCall map[int]struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}
	PrepareTransferStub        func(string, *types.TransferRequest) (*types.TransferResponse, error)
	prepareTransferMutex       sync.RWMutex
	prepareTransferArgsForCall []struct {
		arg1 string
		arg2 *types.TransferRequest
	}
	prepareTransferReturns struct {
		result1 *types.TransferResponse
		result2 error
	}
	prepareTransferReturnsOnCall map[int]struct {
		result1 *types.TransferResponse
		result2 error
	}
	PrepareUpdateStub        func(string, *types.UpdateRequest) (*types.UpdateResponse, error)
	prepareUpdateMutex       sync.RWMutex
	prepareUpdateArgsForCall []struct {
		arg1 string
		arg2 *types.UpdateRequest
	}
	prepareUpdateReturns struct {
		result1 *types.UpdateResponse
		result2 error
	}
	prepareUpdateReturnsOnCall map[int]struct {
		result1 *types.UpdateResponse
		result2 error
	}
	RemoveUserStub        func(string) error
	removeUserMutex       sync.RWMutex
	removeUserArgsForCall []struct {
		arg1 string
	}
	removeUserReturns struct {
		result1 error
	}
	removeUserReturnsOnCall map[int]struct {
		result1 error
	}
	SubmitTxStub        func(*types.SubmitRequest) (*types.SubmitResponse, error)
	submitTxMutex       sync.RWMutex
	submitTxArgsForCall []struct {
		arg1 *types.SubmitRequest
	}
	submitTxReturns struct {
		result1 *types.SubmitResponse
		result2 error
	}
	submitTxReturnsOnCall map[int]struct {
		result1 *types.SubmitResponse
		result2 error
	}
	UpdateUserStub        func(*types.UserRecord) error
	updateUserMutex       sync.RWMutex
	updateUserArgsForCall []struct {
		arg1 *types.UserRecord
	}
	updateUserReturns struct {
		result1 error
	}
	updateUserReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Operations) AddUser(arg1 *types.UserRecord) error {
	fake.addUserMutex.Lock()
	ret, specificReturn := fake.addUserReturnsOnCall[len(fake.addUserArgsForCall)]
	fake.addUserArgsForCall = append(fake.addUserArgsForCall, struct {
		arg1 *types.UserRecord
	}{arg1})
	stub := fake.AddUserStub
	fakeReturns := fake.addUserReturns
	fake.recordInvocation("AddUser", []interface{}{arg1})
	fake.addUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Operations) AddUserCallCount() int {
	fake.addUserMutex.RLock()
	defer fake.addUserMutex.RUnlock()
	return len(fake.addUserArgsForCall)
}

func (fake *Operations) AddUserCalls(stub func(*types.UserRecord) error) {
	fake.addUserMutex.Lock()
	defer fake.addUserMutex.Unlock()
	fake.AddUserStub = stub
}

func (fake *Operations) AddUserArgsForCall(i int) *types.UserRecord {
	fake.addUserMutex.RLock()
	defer fake.addUserMutex.RUnlock()
	argsForCall := fake.addUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) AddUserReturns(result1 error) {
	fake.addUserMutex.Lock()
	defer fake.addUserMutex.Unlock()
	fake.AddUserStub = nil
	fake.addUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *Operations) AddUserReturnsOnCall(i int, result1 error) {
	fake.addUserMutex.Lock()
	defer fake.addUserMutex.Unlock()
	fake.AddUserStub = nil
	if fake.addUserReturnsOnCall == nil {
		fake.addUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Operations) DeployTokenType(arg1 *types.DeployRequest) (*types.DeployResponse, error) {
	fake.deployTokenTypeMutex.Lock()
	ret, specificReturn := fake.deployTokenTypeReturnsOnCall[len(fake.deployTokenTypeArgsForCall)]
	fake.deployTokenTypeArgsForCall = append(fake.deployTokenTypeArgsForCall, struct {
		arg1 *types.DeployRequest
	}{arg1})
	stub := fake.DeployTokenTypeStub
	fakeReturns := fake.deployTokenTypeReturns
	fake.recordInvocation("DeployTokenType", []interface{}{arg1})
	fake.deployTokenTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) DeployTokenTypeCallCount() int {
	fake.deployTokenTypeMutex.RLock()
	defer fake.deployTokenTypeMutex.RUnlock()
	return len(fake.deployTokenTypeArgsForCall)
}

func (fake *Operations) DeployTokenTypeCalls(stub func(*types.DeployRequest) (*types.DeployResponse, error)) {
	fake.deployTokenTypeMutex.Lock()
	defer fake.deployTokenTypeMutex.Unlock()
	fake.DeployTokenTypeStub = stub
}

func (fake *Operations) DeployTokenTypeArgsForCall(i int) *types.DeployRequest {
	fake.deployTokenTypeMutex.RLock()
	defer fake.deployTokenTypeMutex.RUnlock()
	argsForCall := fake.deployTokenTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) DeployTokenTypeReturns(result1 *types.DeployResponse, result2 error) {
	fake.deployTokenTypeMutex.Lock()
	defer fake.deployTokenTypeMutex.Unlock()
	fake.DeployTokenTypeStub = nil
	fake.deployTokenTypeReturns = struct {
		result1 *types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) DeployTokenTypeReturnsOnCall(i int, result1 *types.DeployResponse, result2 error) {
	fake.deployTokenTypeMutex.Lock()
	defer fake.deployTokenTypeMutex.Unlock()
	fake.DeployTokenTypeStub = nil
	if fake.deployTokenTypeReturnsOnCall == nil {
		fake.deployTokenTypeReturnsOnCall = make(map[int]struct {
			result1 *types.DeployResponse
			result2 error
		})
	}
	fake.deployTokenTypeReturnsOnCall[i] = struct {
		result1 *types.DeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleAccounts(arg1 string, arg2 string, arg3 string) ([]types.FungibleAccountRecord, error) {
	fake.fungibleAccountsMutex.Lock()
	ret, specificReturn := fake.fungibleAccountsReturnsOnCall[len(fake.fungibleAccountsArgsForCall)]
	fake.fungibleAccountsArgsForCall = append(fake.fungibleAccountsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FungibleAccountsStub
	fakeReturns := fake.fungibleAccountsReturns
	fake.recordInvocation("FungibleAccounts", []interface{}{arg1, arg2, arg3})
	fake.fungibleAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungibleAccountsCallCount() int {
	fake.fungibleAccountsMutex.RLock()
	defer fake.fungibleAccountsMutex.RUnlock()
	return len(fake.fungibleAccountsArgsForCall)
}

func (fake *Operations) FungibleAccountsCalls(stub func(string, string, string) ([]types.FungibleAccountRecord, error)) {
	fake.fungibleAccountsMutex.Lock()
	defer fake.fungibleAccountsMutex.Unlock()
	fake.FungibleAccountsStub = stub
}

func (fake *Operations) FungibleAccountsArgsForCall(i int) (string, string, string) {
	fake.fungibleAccountsMutex.RLock()
	defer fake.fungibleAccountsMutex.RUnlock()
	argsForCall := fake.fungibleAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Operations) FungibleAccountsReturns(result1 []types.FungibleAccountRecord, result2 error) {
	fake.fungibleAccountsMutex.Lock()
	defer fake.fungibleAccountsMutex.Unlock()
	fake.FungibleAccountsStub = nil
	fake.fungibleAccountsReturns = struct {
		result1 []types.FungibleAccountRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleAccountsReturnsOnCall(i int, result1 []types.FungibleAccountRecord, result2 error) {
	fake.fungibleAccountsMutex.Lock()
	defer fake.fungibleAccountsMutex.Unlock()
	fake.FungibleAccountsStub = nil
	if fake.fungibleAccountsReturnsOnCall == nil {
		fake.fungibleAccountsReturnsOnCall = make(map[int]struct {
			result1 []types.FungibleAccountRecord
			result2 error
		})
	}
	fake.fungibleAccountsReturnsOnCall[i] = struct {
		result1 []types.FungibleAccountRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleDeploy(arg1 *types.FungibleDeployRequest) (*types.FungibleDeployResponse, error) {
	fake.fungibleDeployMutex.Lock()
	ret, specificReturn := fake.fungibleDeployReturnsOnCall[len(fake.fungibleDeployArgsForCall)]
	fake.fungibleDeployArgsForCall = append(fake.fungibleDeployArgsForCall, struct {
		arg1 *types.FungibleDeployRequest
	}{arg1})
	stub := fake.FungibleDeployStub
	fakeReturns := fake.fungibleDeployReturns
	fake.recordInvocation("FungibleDeploy", []interface{}{arg1})
	fake.fungibleDeployMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungibleDeployCallCount() int {
	fake.fungibleDeployMutex.RLock()
	defer fake.fungibleDeployMutex.RUnlock()
	return len(fake.fungibleDeployArgsForCall)
}

func (fake *Operations) FungibleDeployCalls(stub func(*types.FungibleDeployRequest) (*types.FungibleDeployResponse, error)) {
	fake.fungibleDeployMutex.Lock()
	defer fake.fungibleDeployMutex.Unlock()
	fake.FungibleDeployStub = stub
}

func (fake *Operations) FungibleDeployArgsForCall(i int) *types.FungibleDeployRequest {
	fake.fungibleDeployMutex.RLock()
	defer fake.fungibleDeployMutex.RUnlock()
	argsForCall := fake.fungibleDeployArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) FungibleDeployReturns(result1 *types.FungibleDeployResponse, result2 error) {
	fake.fungibleDeployMutex.Lock()
	defer fake.fungibleDeployMutex.Unlock()
	fake.FungibleDeployStub = nil
	fake.fungibleDeployReturns = struct {
		result1 *types.FungibleDeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleDeployReturnsOnCall(i int, result1 *types.FungibleDeployResponse, result2 error) {
	fake.fungibleDeployMutex.Lock()
	defer fake.fungibleDeployMutex.Unlock()
	fake.FungibleDeployStub = nil
	if fake.fungibleDeployReturnsOnCall == nil {
		fake.fungibleDeployReturnsOnCall = make(map[int]struct {
			result1 *types.FungibleDeployResponse
			result2 error
		})
	}
	fake.fungibleDeployReturnsOnCall[i] = struct {
		result1 *types.FungibleDeployResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleDescribe(arg1 string) (*types.FungibleDescribeResponse, error) {
	fake.fungibleDescribeMutex.Lock()
	ret, specificReturn := fake.fungibleDescribeReturnsOnCall[len(fake.fungibleDescribeArgsForCall)]
	fake.fungibleDescribeArgsForCall = append(fake.fungibleDescribeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FungibleDescribeStub
	fakeReturns := fake.fungibleDescribeReturns
	fake.recordInvocation("FungibleDescribe", []interface{}{arg1})
	fake.fungibleDescribeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungibleDescribeCallCount() int {
	fake.fungibleDescribeMutex.RLock()
	defer fake.fungibleDescribeMutex.RUnlock()
	return len(fake.fungibleDescribeArgsForCall)
}

func (fake *Operations) FungibleDescribeCalls(stub func(string) (*types.FungibleDescribeResponse, error)) {
	fake.fungibleDescribeMutex.Lock()
	defer fake.fungibleDescribeMutex.Unlock()
	fake.FungibleDescribeStub = stub
}

func (fake *Operations) FungibleDescribeArgsForCall(i int) string {
	fake.fungibleDescribeMutex.RLock()
	defer fake.fungibleDescribeMutex.RUnlock()
	argsForCall := fake.fungibleDescribeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) FungibleDescribeReturns(result1 *types.FungibleDescribeResponse, result2 error) {
	fake.fungibleDescribeMutex.Lock()
	defer fake.fungibleDescribeMutex.Unlock()
	fake.FungibleDescribeStub = nil
	fake.fungibleDescribeReturns = struct {
		result1 *types.FungibleDescribeResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleDescribeReturnsOnCall(i int, result1 *types.FungibleDescribeResponse, result2 error) {
	fake.fungibleDescribeMutex.Lock()
	defer fake.fungibleDescribeMutex.Unlock()
	fake.FungibleDescribeStub = nil
	if fake.fungibleDescribeReturnsOnCall == nil {
		fake.fungibleDescribeReturnsOnCall = make(map[int]struct {
			result1 *types.FungibleDescribeResponse
			result2 error
		})
	}
	fake.fungibleDescribeReturnsOnCall[i] = struct {
		result1 *types.FungibleDescribeResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungiblePrepareConsolidate(arg1 string, arg2 *types.FungibleConsolidateRequest) (*types.FungibleConsolidateResponse, error) {
	fake.fungiblePrepareConsolidateMutex.Lock()
	ret, specificReturn := fake.fungiblePrepareConsolidateReturnsOnCall[len(fake.fungiblePrepareConsolidateArgsForCall)]
	fake.fungiblePrepareConsolidateArgsForCall = append(fake.fungiblePrepareConsolidateArgsForCall, struct {
		arg1 string
		arg2 *types.FungibleConsolidateRequest
	}{arg1, arg2})
	stub := fake.FungiblePrepareConsolidateStub
	fakeReturns := fake.fungiblePrepareConsolidateReturns
	fake.recordInvocation("FungiblePrepareConsolidate", []interface{}{arg1, arg2})
	fake.fungiblePrepareConsolidateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungiblePrepareConsolidateCallCount() int {
	fake.fungiblePrepareConsolidateMutex.RLock()
	defer fake.fungiblePrepareConsolidateMutex.RUnlock()
	return len(fake.fungiblePrepareConsolidateArgsForCall)
}

func (fake *Operations) FungiblePrepareConsolidateCalls(stub func(string, *types.FungibleConsolidateRequest) (*types.FungibleConsolidateResponse, error)) {
	fake.fungiblePrepareConsolidateMutex.Lock()
	defer fake.fungiblePrepareConsolidateMutex.Unlock()
	fake.FungiblePrepareConsolidateStub = stub
}

func (fake *Operations) FungiblePrepareConsolidateArgsForCall(i int) (string, *types.FungibleConsolidateRequest) {
	fake.fungiblePrepareConsolidateMutex.RLock()
	defer fake.fungiblePrepareConsolidateMutex.RUnlock()
	argsForCall := fake.fungiblePrepareConsolidateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) FungiblePrepareConsolidateReturns(result1 *types.FungibleConsolidateResponse, result2 error) {
	fake.fungiblePrepareConsolidateMutex.Lock()
	defer fake.fungiblePrepareConsolidateMutex.Unlock()
	fake.FungiblePrepareConsolidateStub = nil
	fake.fungiblePrepareConsolidateReturns = struct {
		result1 *types.FungibleConsolidateResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungiblePrepareConsolidateReturnsOnCall(i int, result1 *types.FungibleConsolidateResponse, result2 error) {
	fake.fungiblePrepareConsolidateMutex.Lock()
	defer fake.fungiblePrepareConsolidateMutex.Unlock()
	fake.FungiblePrepareConsolidateStub = nil
	if fake.fungiblePrepareConsolidateReturnsOnCall == nil {
		fake.fungiblePrepareConsolidateReturnsOnCall = make(map[int]struct {
			result1 *types.FungibleConsolidateResponse
			result2 error
		})
	}
	fake.fungiblePrepareConsolidateReturnsOnCall[i] = struct {
		result1 *types.FungibleConsolidateResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungiblePrepareMint(arg1 string, arg2 *types.FungibleMintRequest) (*types.FungibleMintResponse, error) {
	fake.fungiblePrepareMintMutex.Lock()
	ret, specificReturn := fake.fungiblePrepareMintReturnsOnCall[len(fake.fungiblePrepareMintArgsForCall)]
	fake.fungiblePrepareMintArgsForCall = append(fake.fungiblePrepareMintArgsForCall, struct {
		arg1 string
		arg2 *types.FungibleMintRequest
	}{arg1, arg2})
	stub := fake.FungiblePrepareMintStub
	fakeReturns := fake.fungiblePrepareMintReturns
	fake.recordInvocation("FungiblePrepareMint", []interface{}{arg1, arg2})
	fake.fungiblePrepareMintMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungiblePrepareMintCallCount() int {
	fake.fungiblePrepareMintMutex.RLock()
	defer fake.fungiblePrepareMintMutex.RUnlock()
	return len(fake.fungiblePrepareMintArgsForCall)
}

func (fake *Operations) FungiblePrepareMintCalls(stub func(string, *types.FungibleMintRequest) (*types.FungibleMintResponse, error)) {
	fake.fungiblePrepareMintMutex.Lock()
	defer fake.fungiblePrepareMintMutex.Unlock()
	fake.FungiblePrepareMintStub = stub
}

func (fake *Operations) FungiblePrepareMintArgsForCall(i int) (string, *types.FungibleMintRequest) {
	fake.fungiblePrepareMintMutex.RLock()
	defer fake.fungiblePrepareMintMutex.RUnlock()
	argsForCall := fake.fungiblePrepareMintArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) FungiblePrepareMintReturns(result1 *types.FungibleMintResponse, result2 error) {
	fake.fungiblePrepareMintMutex.Lock()
	defer fake.fungiblePrepareMintMutex.Unlock()
	fake.FungiblePrepareMintStub = nil
	fake.fungiblePrepareMintReturns = struct {
		result1 *types.FungibleMintResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungiblePrepareMintReturnsOnCall(i int, result1 *types.FungibleMintResponse, result2 error) {
	fake.fungiblePrepareMintMutex.Lock()
	defer fake.fungiblePrepareMintMutex.Unlock()
	fake.FungiblePrepareMintStub = nil
	if fake.fungiblePrepareMintReturnsOnCall == nil {
		fake.fungiblePrepareMintReturnsOnCall = make(map[int]struct {
			result1 *types.FungibleMintResponse
			result2 error
		})
	}
	fake.fungiblePrepareMintReturnsOnCall[i] = struct {
		result1 *types.FungibleMintResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungiblePrepareTransfer(arg1 string, arg2 *types.FungibleTransferRequest) (*types.FungibleTransferResponse, error) {
	fake.fungiblePrepareTransferMutex.Lock()
	ret, specificReturn := fake.fungiblePrepareTransferReturnsOnCall[len(fake.fungiblePrepareTransferArgsForCall)]
	fake.fungiblePrepareTransferArgsForCall = append(fake.fungiblePrepareTransferArgsForCall, struct {
		arg1 string
		arg2 *types.FungibleTransferRequest
	}{arg1, arg2})
	stub := fake.FungiblePrepareTransferStub
	fakeReturns := fake.fungiblePrepareTransferReturns
	fake.recordInvocation("FungiblePrepareTransfer", []interface{}{arg1, arg2})
	fake.fungiblePrepareTransferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungiblePrepareTransferCallCount() int {
	fake.fungiblePrepareTransferMutex.RLock()
	defer fake.fungiblePrepareTransferMutex.RUnlock()
	return len(fake.fungiblePrepareTransferArgsForCall)
}

func (fake *Operations) FungiblePrepareTransferCalls(stub func(string, *types.FungibleTransferRequest) (*types.FungibleTransferResponse, error)) {
	fake.fungiblePrepareTransferMutex.Lock()
	defer fake.fungiblePrepareTransferMutex.Unlock()
	fake.FungiblePrepareTransferStub = stub
}

func (fake *Operations) FungiblePrepareTransferArgsForCall(i int) (string, *types.FungibleTransferRequest) {
	fake.fungiblePrepareTransferMutex.RLock()
	defer fake.fungiblePrepareTransferMutex.RUnlock()
	argsForCall := fake.fungiblePrepareTransferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) FungiblePrepareTransferReturns(result1 *types.FungibleTransferResponse, result2 error) {
	fake.fungiblePrepareTransferMutex.Lock()
	defer fake.fungiblePrepareTransferMutex.Unlock()
	fake.FungiblePrepareTransferStub = nil
	fake.fungiblePrepareTransferReturns = struct {
		result1 *types.FungibleTransferResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungiblePrepareTransferReturnsOnCall(i int, result1 *types.FungibleTransferResponse, result2 error) {
	fake.fungiblePrepareTransferMutex.Lock()
	defer fake.fungiblePrepareTransferMutex.Unlock()
	fake.FungiblePrepareTransferStub = nil
	if fake.fungiblePrepareTransferReturnsOnCall == nil {
		fake.fungiblePrepareTransferReturnsOnCall = make(map[int]struct {
			result1 *types.FungibleTransferResponse
			result2 error
		})
	}
	fake.fungiblePrepareTransferReturnsOnCall[i] = struct {
		result1 *types.FungibleTransferResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleSubmitTx(arg1 *types.FungibleSubmitRequest) (*types.FungibleSubmitResponse, error) {
	fake.fungibleSubmitTxMutex.Lock()
	ret, specificReturn := fake.fungibleSubmitTxReturnsOnCall[len(fake.fungibleSubmitTxArgsForCall)]
	fake.fungibleSubmitTxArgsForCall = append(fake.fungibleSubmitTxArgsForCall, struct {
		arg1 *types.FungibleSubmitRequest
	}{arg1})
	stub := fake.FungibleSubmitTxStub
	fakeReturns := fake.fungibleSubmitTxReturns
	fake.recordInvocation("FungibleSubmitTx", []interface{}{arg1})
	fake.fungibleSubmitTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) FungibleSubmitTxCallCount() int {
	fake.fungibleSubmitTxMutex.RLock()
	defer fake.fungibleSubmitTxMutex.RUnlock()
	return len(fake.fungibleSubmitTxArgsForCall)
}

func (fake *Operations) FungibleSubmitTxCalls(stub func(*types.FungibleSubmitRequest) (*types.FungibleSubmitResponse, error)) {
	fake.fungibleSubmitTxMutex.Lock()
	defer fake.fungibleSubmitTxMutex.Unlock()
	fake.FungibleSubmitTxStub = stub
}

func (fake *Operations) FungibleSubmitTxArgsForCall(i int) *types.FungibleSubmitRequest {
	fake.fungibleSubmitTxMutex.RLock()
	defer fake.fungibleSubmitTxMutex.RUnlock()
	argsForCall := fake.fungibleSubmitTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) FungibleSubmitTxReturns(result1 *types.FungibleSubmitResponse, result2 error) {
	fake.fungibleSubmitTxMutex.Lock()
	defer fake.fungibleSubmitTxMutex.Unlock()
	fake.FungibleSubmitTxStub = nil
	fake.fungibleSubmitTxReturns = struct {
		result1 *types.FungibleSubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) FungibleSubmitTxReturnsOnCall(i int, result1 *types.FungibleSubmitResponse, result2 error) {
	fake.fungibleSubmitTxMutex.Lock()
	defer fake.fungibleSubmitTxMutex.Unlock()
	fake.FungibleSubmitTxStub = nil
	if fake.fungibleSubmitTxReturnsOnCall == nil {
		fake.fungibleSubmitTxReturnsOnCall = make(map[int]struct {
			result1 *types.FungibleSubmitResponse
			result2 error
		})
	}
	fake.fungibleSubmitTxReturnsOnCall[i] = struct {
		result1 *types.FungibleSubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotation(arg1 string) (*types.AnnotationRecord, error) {
	fake.getAnnotationMutex.Lock()
	ret, specificReturn := fake.getAnnotationReturnsOnCall[len(fake.getAnnotationArgsForCall)]
	fake.getAnnotationArgsForCall = append(fake.getAnnotationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAnnotationStub
	fakeReturns := fake.getAnnotationReturns
	fake.recordInvocation("GetAnnotation", []interface{}{arg1})
	fake.getAnnotationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetAnnotationCallCount() int {
	fake.getAnnotationMutex.RLock()
	defer fake.getAnnotationMutex.RUnlock()
	return len(fake.getAnnotationArgsForCall)
}

func (fake *Operations) GetAnnotationCalls(stub func(string) (*types.AnnotationRecord, error)) {
	fake.getAnnotationMutex.Lock()
	defer fake.getAnnotationMutex.Unlock()
	fake.GetAnnotationStub = stub
}

func (fake *Operations) GetAnnotationArgsForCall(i int) string {
	fake.getAnnotationMutex.RLock()
	defer fake.getAnnotationMutex.RUnlock()
	argsForCall := fake.getAnnotationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetAnnotationReturns(result1 *types.AnnotationRecord, result2 error) {
	fake.getAnnotationMutex.Lock()
	defer fake.getAnnotationMutex.Unlock()
	fake.GetAnnotationStub = nil
	fake.getAnnotationReturns = struct {
		result1 *types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotationReturnsOnCall(i int, result1 *types.AnnotationRecord, result2 error) {
	fake.getAnnotationMutex.Lock()
	defer fake.getAnnotationMutex.Unlock()
	fake.GetAnnotationStub = nil
	if fake.getAnnotationReturnsOnCall == nil {
		fake.getAnnotationReturnsOnCall = make(map[int]struct {
			result1 *types.AnnotationRecord
			result2 error
		})
	}
	fake.getAnnotationReturnsOnCall[i] = struct {
		result1 *types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotationsByFilter(arg1 string, arg2 string, arg3 string, arg4 string) ([]*types.AnnotationRecord, error) {
	fake.getAnnotationsByFilterMutex.Lock()
	ret, specificReturn := fake.getAnnotationsByFilterReturnsOnCall[len(fake.getAnnotationsByFilterArgsForCall)]
	fake.getAnnotationsByFilterArgsForCall = append(fake.getAnnotationsByFilterArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetAnnotationsByFilterStub
	fakeReturns := fake.getAnnotationsByFilterReturns
	fake.recordInvocation("GetAnnotationsByFilter", []interface{}{arg1, arg2, arg3, arg4})
	fake.getAnnotationsByFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetAnnotationsByFilterCallCount() int {
	fake.getAnnotationsByFilterMutex.RLock()
	defer fake.getAnnotationsByFilterMutex.RUnlock()
	return len(fake.getAnnotationsByFilterArgsForCall)
}

func (fake *Operations) GetAnnotationsByFilterCalls(stub func(string, string, string, string) ([]*types.AnnotationRecord, error)) {
	fake.getAnnotationsByFilterMutex.Lock()
	defer fake.getAnnotationsByFilterMutex.Unlock()
	fake.GetAnnotationsByFilterStub = stub
}

func (fake *Operations) GetAnnotationsByFilterArgsForCall(i int) (string, string, string, string) {
	fake.getAnnotationsByFilterMutex.RLock()
	defer fake.getAnnotationsByFilterMutex.RUnlock()
	argsForCall := fake.getAnnotationsByFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Operations) GetAnnotationsByFilterReturns(result1 []*types.AnnotationRecord, result2 error) {
	fake.getAnnotationsByFilterMutex.Lock()
	defer fake.getAnnotationsByFilterMutex.Unlock()
	fake.GetAnnotationsByFilterStub = nil
	fake.getAnnotationsByFilterReturns = struct {
		result1 []*types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetAnnotationsByFilterReturnsOnCall(i int, result1 []*types.AnnotationRecord, result2 error) {
	fake.getAnnotationsByFilterMutex.Lock()
	defer fake.getAnnotationsByFilterMutex.Unlock()
	fake.GetAnnotationsByFilterStub = nil
	if fake.getAnnotationsByFilterReturnsOnCall == nil {
		fake.getAnnotationsByFilterReturnsOnCall = make(map[int]struct {
			result1 []*types.AnnotationRecord
			result2 error
		})
	}
	fake.getAnnotationsByFilterReturnsOnCall[i] = struct {
		result1 []*types.AnnotationRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetStatus() (string, error) {
	fake.getStatusMutex.Lock()
	ret, specificReturn := fake.getStatusReturnsOnCall[len(fake.getStatusArgsForCall)]
	fake.getStatusArgsForCall = append(fake.getStatusArgsForCall, struct {
	}{})
	stub := fake.GetStatusStub
	fakeReturns := fake.getStatusReturns
	fake.recordInvocation("GetStatus", []interface{}{})
	fake.getStatusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetStatusCallCount() int {
	fake.getStatusMutex.RLock()
	defer fake.getStatusMutex.RUnlock()
	return len(fake.getStatusArgsForCall)
}

func (fake *Operations) GetStatusCalls(stub func() (string, error)) {
	fake.getStatusMutex.Lock()
	defer fake.getStatusMutex.Unlock()
	fake.GetStatusStub = stub
}

func (fake *Operations) GetStatusReturns(result1 string, result2 error) {
	fake.getStatusMutex.Lock()
	defer fake.getStatusMutex.Unlock()
	fake.GetStatusStub = nil
	fake.getStatusReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetStatusReturnsOnCall(i int, result1 string, result2 error) {
	fake.getStatusMutex.Lock()
	defer fake.getStatusMutex.Unlock()
	fake.GetStatusStub = nil
	if fake.getStatusReturnsOnCall == nil {
		fake.getStatusReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStatusReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetToken(arg1 string) (*types.TokenRecord, error) {
	fake.getTokenMutex.Lock()
	ret, specificReturn := fake.getTokenReturnsOnCall[len(fake.getTokenArgsForCall)]
	fake.getTokenArgsForCall = append(fake.getTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTokenStub
	fakeReturns := fake.getTokenReturns
	fake.recordInvocation("GetToken", []interface{}{arg1})
	fake.getTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokenCallCount() int {
	fake.getTokenMutex.RLock()
	defer fake.getTokenMutex.RUnlock()
	return len(fake.getTokenArgsForCall)
}

func (fake *Operations) GetTokenCalls(stub func(string) (*types.TokenRecord, error)) {
	fake.getTokenMutex.Lock()
	defer fake.getTokenMutex.Unlock()
	fake.GetTokenStub = stub
}

func (fake *Operations) GetTokenArgsForCall(i int) string {
	fake.getTokenMutex.RLock()
	defer fake.getTokenMutex.RUnlock()
	argsForCall := fake.getTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetTokenReturns(result1 *types.TokenRecord, result2 error) {
	fake.getTokenMutex.Lock()
	defer fake.getTokenMutex.Unlock()
	fake.GetTokenStub = nil
	fake.getTokenReturns = struct {
		result1 *types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenReturnsOnCall(i int, result1 *types.TokenRecord, result2 error) {
	fake.getTokenMutex.Lock()
	defer fake.getTokenMutex.Unlock()
	fake.GetTokenStub = nil
	if fake.getTokenReturnsOnCall == nil {
		fake.getTokenReturnsOnCall = make(map[int]struct {
			result1 *types.TokenRecord
			result2 error
		})
	}
	fake.getTokenReturnsOnCall[i] = struct {
		result1 *types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenType(arg1 string) (*types.TokenDescription, error) {
	fake.getTokenTypeMutex.Lock()
	ret, specificReturn := fake.getTokenTypeReturnsOnCall[len(fake.getTokenTypeArgsForCall)]
	fake.getTokenTypeArgsForCall = append(fake.getTokenTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTokenTypeStub
	fakeReturns := fake.getTokenTypeReturns
	fake.recordInvocation("GetTokenType", []interface{}{arg1})
	fake.getTokenTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokenTypeCallCount() int {
	fake.getTokenTypeMutex.RLock()
	defer fake.getTokenTypeMutex.RUnlock()
	return len(fake.getTokenTypeArgsForCall)
}

func (fake *Operations) GetTokenTypeCalls(stub func(string) (*types.TokenDescription, error)) {
	fake.getTokenTypeMutex.Lock()
	defer fake.getTokenTypeMutex.Unlock()
	fake.GetTokenTypeStub = stub
}

func (fake *Operations) GetTokenTypeArgsForCall(i int) string {
	fake.getTokenTypeMutex.RLock()
	defer fake.getTokenTypeMutex.RUnlock()
	argsForCall := fake.getTokenTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetTokenTypeReturns(result1 *types.TokenDescription, result2 error) {
	fake.getTokenTypeMutex.Lock()
	defer fake.getTokenTypeMutex.Unlock()
	fake.GetTokenTypeStub = nil
	fake.getTokenTypeReturns = struct {
		result1 *types.TokenDescription
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenTypeReturnsOnCall(i int, result1 *types.TokenDescription, result2 error) {
	fake.getTokenTypeMutex.Lock()
	defer fake.getTokenTypeMutex.Unlock()
	fake.GetTokenTypeStub = nil
	if fake.getTokenTypeReturnsOnCall == nil {
		fake.getTokenTypeReturnsOnCall = make(map[int]struct {
			result1 *types.TokenDescription
			result2 error
		})
	}
	fake.getTokenTypeReturnsOnCall[i] = struct {
		result1 *types.TokenDescription
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenTypes() ([]*types.TokenDescription, error) {
	fake.getTokenTypesMutex.Lock()
	ret, specificReturn := fake.getTokenTypesReturnsOnCall[len(fake.getTokenTypesArgsForCall)]
	fake.getTokenTypesArgsForCall = append(fake.getTokenTypesArgsForCall, struct {
	}{})
	stub := fake.GetTokenTypesStub
	fakeReturns := fake.getTokenTypesReturns
	fake.recordInvocation("GetTokenTypes", []interface{}{})
	fake.getTokenTypesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokenTypesCallCount() int {
	fake.getTokenTypesMutex.RLock()
	defer fake.getTokenTypesMutex.RUnlock()
	return len(fake.getTokenTypesArgsForCall)
}

func (fake *Operations) GetTokenTypesCalls(stub func() ([]*types.TokenDescription, error)) {
	fake.getTokenTypesMutex.Lock()
	defer fake.getTokenTypesMutex.Unlock()
	fake.GetTokenTypesStub = stub
}

func (fake *Operations) GetTokenTypesReturns(result1 []*types.TokenDescription, result2 error) {
	fake.getTokenTypesMutex.Lock()
	defer fake.getTokenTypesMutex.Unlock()
	fake.GetTokenTypesStub = nil
	fake.getTokenTypesReturns = struct {
		result1 []*types.TokenDescription
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokenTypesReturnsOnCall(i int, result1 []*types.TokenDescription, result2 error) {
	fake.getTokenTypesMutex.Lock()
	defer fake.getTokenTypesMutex.Unlock()
	fake.GetTokenTypesStub = nil
	if fake.getTokenTypesReturnsOnCall == nil {
		fake.getTokenTypesReturnsOnCall = make(map[int]struct {
			result1 []*types.TokenDescription
			result2 error
		})
	}
	fake.getTokenTypesReturnsOnCall[i] = struct {
		result1 []*types.TokenDescription
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokensByFilter(arg1 string, arg2 string, arg3 string, arg4 string) ([]*types.TokenRecord, error) {
	fake.getTokensByFilterMutex.Lock()
	ret, specificReturn := fake.getTokensByFilterReturnsOnCall[len(fake.getTokensByFilterArgsForCall)]
	fake.getTokensByFilterArgsForCall = append(fake.getTokensByFilterArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetTokensByFilterStub
	fakeReturns := fake.getTokensByFilterReturns
	fake.recordInvocation("GetTokensByFilter", []interface{}{arg1, arg2, arg3, arg4})
	fake.getTokensByFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetTokensByFilterCallCount() int {
	fake.getTokensByFilterMutex.RLock()
	defer fake.getTokensByFilterMutex.RUnlock()
	return len(fake.getTokensByFilterArgsForCall)
}

func (fake *Operations) GetTokensByFilterCalls(stub func(string, string, string, string) ([]*types.TokenRecord, error)) {
	fake.getTokensByFilterMutex.Lock()
	defer fake.getTokensByFilterMutex.Unlock()
	fake.GetTokensByFilterStub = stub
}

func (fake *Operations) GetTokensByFilterArgsForCall(i int) (string, string, string, string) {
	fake.getTokensByFilterMutex.RLock()
	defer fake.getTokensByFilterMutex.RUnlock()
	argsForCall := fake.getTokensByFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Operations) GetTokensByFilterReturns(result1 []*types.TokenRecord, result2 error) {
	fake.getTokensByFilterMutex.Lock()
	defer fake.getTokensByFilterMutex.Unlock()
	fake.GetTokensByFilterStub = nil
	fake.getTokensByFilterReturns = struct {
		result1 []*types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetTokensByFilterReturnsOnCall(i int, result1 []*types.TokenRecord, result2 error) {
	fake.getTokensByFilterMutex.Lock()
	defer fake.getTokensByFilterMutex.Unlock()
	fake.GetTokensByFilterStub = nil
	if fake.getTokensByFilterReturnsOnCall == nil {
		fake.getTokensByFilterReturnsOnCall = make(map[int]struct {
			result1 []*types.TokenRecord
			result2 error
		})
	}
	fake.getTokensByFilterReturnsOnCall[i] = struct {
		result1 []*types.TokenRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetUser(arg1 string) (*types.UserRecord, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *Operations) GetUserCalls(stub func(string) (*types.UserRecord, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *Operations) GetUserArgsForCall(i int) string {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) GetUserReturns(result1 *types.UserRecord, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 *types.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) GetUserReturnsOnCall(i int, result1 *types.UserRecord, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 *types.UserRecord
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 *types.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareMint(arg1 string, arg2 *types.MintRequest) (*types.MintResponse, error) {
	fake.prepareMintMutex.Lock()
	ret, specificReturn := fake.prepareMintReturnsOnCall[len(fake.prepareMintArgsForCall)]
	fake.prepareMintArgsForCall = append(fake.prepareMintArgsForCall, struct {
		arg1 string
		arg2 *types.MintRequest
	}{arg1, arg2})
	stub := fake.PrepareMintStub
	fakeReturns := fake.prepareMintReturns
	fake.recordInvocation("PrepareMint", []interface{}{arg1, arg2})
	fake.prepareMintMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareMintCallCount() int {
	fake.prepareMintMutex.RLock()
	defer fake.prepareMintMutex.RUnlock()
	return len(fake.prepareMintArgsForCall)
}

func (fake *Operations) PrepareMintCalls(stub func(string, *types.MintRequest) (*types.MintResponse, error)) {
	fake.prepareMintMutex.Lock()
	defer fake.prepareMintMutex.Unlock()
	fake.PrepareMintStub = stub
}

func (fake *Operations) PrepareMintArgsForCall(i int) (string, *types.MintRequest) {
	fake.prepareMintMutex.RLock()
	defer fake.prepareMintMutex.RUnlock()
	argsForCall := fake.prepareMintArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareMintReturns(result1 *types.MintResponse, result2 error) {
	fake.prepareMintMutex.Lock()
	defer fake.prepareMintMutex.Unlock()
	fake.PrepareMintStub = nil
	fake.prepareMintReturns = struct {
		result1 *types.MintResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareMintReturnsOnCall(i int, result1 *types.MintResponse, result2 error) {
	fake.prepareMintMutex.Lock()
	defer fake.prepareMintMutex.Unlock()
	fake.PrepareMintStub = nil
	if fake.prepareMintReturnsOnCall == nil {
		fake.prepareMintReturnsOnCall = make(map[int]struct {
			result1 *types.MintResponse
			result2 error
		})
	}
	fake.prepareMintReturnsOnCall[i] = struct {
		result1 *types.MintResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareRegister(arg1 string, arg2 *types.AnnotationRegisterRequest) (*types.AnnotationRegisterResponse, error) {
	fake.prepareRegisterMutex.Lock()
	ret, specificReturn := fake.prepareRegisterReturnsOnCall[len(fake.prepareRegisterArgsForCall)]
	fake.prepareRegisterArgsForCall = append(fake.prepareRegisterArgsForCall, struct {
		arg1 string
		arg2 *types.AnnotationRegisterRequest
	}{arg1, arg2})
	stub := fake.PrepareRegisterStub
	fakeReturns := fake.prepareRegisterReturns
	fake.recordInvocation("PrepareRegister", []interface{}{arg1, arg2})
	fake.prepareRegisterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareRegisterCallCount() int {
	fake.prepareRegisterMutex.RLock()
	defer fake.prepareRegisterMutex.RUnlock()
	return len(fake.prepareRegisterArgsForCall)
}

func (fake *Operations) PrepareRegisterCalls(stub func(string, *types.AnnotationRegisterRequest) (*types.AnnotationRegisterResponse, error)) {
	fake.prepareRegisterMutex.Lock()
	defer fake.prepareRegisterMutex.Unlock()
	fake.PrepareRegisterStub = stub
}

func (fake *Operations) PrepareRegisterArgsForCall(i int) (string, *types.AnnotationRegisterRequest) {
	fake.prepareRegisterMutex.RLock()
	defer fake.prepareRegisterMutex.RUnlock()
	argsForCall := fake.prepareRegisterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareRegisterReturns(result1 *types.AnnotationRegisterResponse, result2 error) {
	fake.prepareRegisterMutex.Lock()
	defer fake.prepareRegisterMutex.Unlock()
	fake.PrepareRegisterStub = nil
	fake.prepareRegisterReturns = struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareRegisterReturnsOnCall(i int, result1 *types.AnnotationRegisterResponse, result2 error) {
	fake.prepareRegisterMutex.Lock()
	defer fake.prepareRegisterMutex.Unlock()
	fake.PrepareRegisterStub = nil
	if fake.prepareRegisterReturnsOnCall == nil {
		fake.prepareRegisterReturnsOnCall = make(map[int]struct {
			result1 *types.AnnotationRegisterResponse
			result2 error
		})
	}
	fake.prepareRegisterReturnsOnCall[i] = struct {
		result1 *types.AnnotationRegisterResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareTransfer(arg1 string, arg2 *types.TransferRequest) (*types.TransferResponse, error) {
	fake.prepareTransferMutex.Lock()
	ret, specificReturn := fake.prepareTransferReturnsOnCall[len(fake.prepareTransferArgsForCall)]
	fake.prepareTransferArgsForCall = append(fake.prepareTransferArgsForCall, struct {
		arg1 string
		arg2 *types.TransferRequest
	}{arg1, arg2})
	stub := fake.PrepareTransferStub
	fakeReturns := fake.prepareTransferReturns
	fake.recordInvocation("PrepareTransfer", []interface{}{arg1, arg2})
	fake.prepareTransferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareTransferCallCount() int {
	fake.prepareTransferMutex.RLock()
	defer fake.prepareTransferMutex.RUnlock()
	return len(fake.prepareTransferArgsForCall)
}

func (fake *Operations) PrepareTransferCalls(stub func(string, *types.TransferRequest) (*types.TransferResponse, error)) {
	fake.prepareTransferMutex.Lock()
	defer fake.prepareTransferMutex.Unlock()
	fake.PrepareTransferStub = stub
}

func (fake *Operations) PrepareTransferArgsForCall(i int) (string, *types.TransferRequest) {
	fake.prepareTransferMutex.RLock()
	defer fake.prepareTransferMutex.RUnlock()
	argsForCall := fake.prepareTransferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareTransferReturns(result1 *types.TransferResponse, result2 error) {
	fake.prepareTransferMutex.Lock()
	defer fake.prepareTransferMutex.Unlock()
	fake.PrepareTransferStub = nil
	fake.prepareTransferReturns = struct {
		result1 *types.TransferResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareTransferReturnsOnCall(i int, result1 *types.TransferResponse, result2 error) {
	fake.prepareTransferMutex.Lock()
	defer fake.prepareTransferMutex.Unlock()
	fake.PrepareTransferStub = nil
	if fake.prepareTransferReturnsOnCall == nil {
		fake.prepareTransferReturnsOnCall = make(map[int]struct {
			result1 *types.TransferResponse
			result2 error
		})
	}
	fake.prepareTransferReturnsOnCall[i] = struct {
		result1 *types.TransferResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareUpdate(arg1 string, arg2 *types.UpdateRequest) (*types.UpdateResponse, error) {
	fake.prepareUpdateMutex.Lock()
	ret, specificReturn := fake.prepareUpdateReturnsOnCall[len(fake.prepareUpdateArgsForCall)]
	fake.prepareUpdateArgsForCall = append(fake.prepareUpdateArgsForCall, struct {
		arg1 string
		arg2 *types.UpdateRequest
	}{arg1, arg2})
	stub := fake.PrepareUpdateStub
	fakeReturns := fake.prepareUpdateReturns
	fake.recordInvocation("PrepareUpdate", []interface{}{arg1, arg2})
	fake.prepareUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) PrepareUpdateCallCount() int {
	fake.prepareUpdateMutex.RLock()
	defer fake.prepareUpdateMutex.RUnlock()
	return len(fake.prepareUpdateArgsForCall)
}

func (fake *Operations) PrepareUpdateCalls(stub func(string, *types.UpdateRequest) (*types.UpdateResponse, error)) {
	fake.prepareUpdateMutex.Lock()
	defer fake.prepareUpdateMutex.Unlock()
	fake.PrepareUpdateStub = stub
}

func (fake *Operations) PrepareUpdateArgsForCall(i int) (string, *types.UpdateRequest) {
	fake.prepareUpdateMutex.RLock()
	defer fake.prepareUpdateMutex.RUnlock()
	argsForCall := fake.prepareUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Operations) PrepareUpdateReturns(result1 *types.UpdateResponse, result2 error) {
	fake.prepareUpdateMutex.Lock()
	defer fake.prepareUpdateMutex.Unlock()
	fake.PrepareUpdateStub = nil
	fake.prepareUpdateReturns = struct {
		result1 *types.UpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) PrepareUpdateReturnsOnCall(i int, result1 *types.UpdateResponse, result2 error) {
	fake.prepareUpdateMutex.Lock()
	defer fake.prepareUpdateMutex.Unlock()
	fake.PrepareUpdateStub = nil
	if fake.prepareUpdateReturnsOnCall == nil {
		fake.prepareUpdateReturnsOnCall = make(map[int]struct {
			result1 *types.UpdateResponse
			result2 error
		})
	}
	fake.prepareUpdateReturnsOnCall[i] = struct {
		result1 *types.UpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) RemoveUser(arg1 string) error {
	fake.removeUserMutex.Lock()
	ret, specificReturn := fake.removeUserReturnsOnCall[len(fake.removeUserArgsForCall)]
	fake.removeUserArgsForCall = append(fake.removeUserArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveUserStub
	fakeReturns := fake.removeUserReturns
	fake.recordInvocation("RemoveUser", []interface{}{arg1})
	fake.removeUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Operations) RemoveUserCallCount() int {
	fake.removeUserMutex.RLock()
	defer fake.removeUserMutex.RUnlock()
	return len(fake.removeUserArgsForCall)
}

func (fake *Operations) RemoveUserCalls(stub func(string) error) {
	fake.removeUserMutex.Lock()
	defer fake.removeUserMutex.Unlock()
	fake.RemoveUserStub = stub
}

func (fake *Operations) RemoveUserArgsForCall(i int) string {
	fake.removeUserMutex.RLock()
	defer fake.removeUserMutex.RUnlock()
	argsForCall := fake.removeUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) RemoveUserReturns(result1 error) {
	fake.removeUserMutex.Lock()
	defer fake.removeUserMutex.Unlock()
	fake.RemoveUserStub = nil
	fake.removeUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *Operations) RemoveUserReturnsOnCall(i int, result1 error) {
	fake.removeUserMutex.Lock()
	defer fake.removeUserMutex.Unlock()
	fake.RemoveUserStub = nil
	if fake.removeUserReturnsOnCall == nil {
		fake.removeUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Operations) SubmitTx(arg1 *types.SubmitRequest) (*types.SubmitResponse, error) {
	fake.submitTxMutex.Lock()
	ret, specificReturn := fake.submitTxReturnsOnCall[len(fake.submitTxArgsForCall)]
	fake.submitTxArgsForCall = append(fake.submitTxArgsForCall, struct {
		arg1 *types.SubmitRequest
	}{arg1})
	stub := fake.SubmitTxStub
	fakeReturns := fake.submitTxReturns
	fake.recordInvocation("SubmitTx", []interface{}{arg1})
	fake.submitTxMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Operations) SubmitTxCallCount() int {
	fake.submitTxMutex.RLock()
	defer fake.submitTxMutex.RUnlock()
	return len(fake.submitTxArgsForCall)
}

func (fake *Operations) SubmitTxCalls(stub func(*types.SubmitRequest) (*types.SubmitResponse, error)) {
	fake.submitTxMutex.Lock()
	defer fake.submitTxMutex.Unlock()
	fake.SubmitTxStub = stub
}

func (fake *Operations) SubmitTxArgsForCall(i int) *types.SubmitRequest {
	fake.submitTxMutex.RLock()
	defer fake.submitTxMutex.RUnlock()
	argsForCall := fake.submitTxArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) SubmitTxReturns(result1 *types.SubmitResponse, result2 error) {
	fake.submitTxMutex.Lock()
	defer fake.submitTxMutex.Unlock()
	fake.SubmitTxStub = nil
	fake.submitTxReturns = struct {
		result1 *types.SubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) SubmitTxReturnsOnCall(i int, result1 *types.SubmitResponse, result2 error) {
	fake.submitTxMutex.Lock()
	defer fake.submitTxMutex.Unlock()
	fake.SubmitTxStub = nil
	if fake.submitTxReturnsOnCall == nil {
		fake.submitTxReturnsOnCall = make(map[int]struct {
			result1 *types.SubmitResponse
			result2 error
		})
	}
	fake.submitTxReturnsOnCall[i] = struct {
		result1 *types.SubmitResponse
		result2 error
	}{result1, result2}
}

func (fake *Operations) UpdateUser(arg1 *types.UserRecord) error {
	fake.updateUserMutex.Lock()
	ret, specificReturn := fake.updateUserReturnsOnCall[len(fake.updateUserArgsForCall)]
	fake.updateUserArgsForCall = append(fake.updateUserArgsForCall, struct {
		arg1 *types.UserRecord
	}{arg1})
	stub := fake.UpdateUserStub
	fakeReturns := fake.updateUserReturns
	fake.recordInvocation("UpdateUser", []interface{}{arg1})
	fake.updateUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Operations) UpdateUserCallCount() int {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	return len(fake.updateUserArgsForCall)
}

func (fake *Operations) UpdateUserCalls(stub func(*types.UserRecord) error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = stub
}

func (fake *Operations) UpdateUserArgsForCall(i int) *types.UserRecord {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	argsForCall := fake.updateUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Operations) UpdateUserReturns(result1 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	fake.updateUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *Operations) UpdateUserReturnsOnCall(i int, result1 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	if fake.updateUserReturnsOnCall == nil {
		fake.updateUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Operations) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addUserMutex.RLock()
	defer fake.addUserMutex.RUnlock()
	fake.deployTokenTypeMutex.RLock()
	defer fake.deployTokenTypeMutex.RUnlock()
	fake.fungibleAccountsMutex.RLock()
	defer fake.fungibleAccountsMutex.RUnlock()
	fake.fungibleDeployMutex.RLock()
	defer fake.fungibleDeployMutex.RUnlock()
	fake.fungibleDescribeMutex.RLock()
	defer fake.fungibleDescribeMutex.RUnlock()
	fake.fungiblePrepareConsolidateMutex.RLock()
	defer fake.fungiblePrepareConsolidateMutex.RUnlock()
	fake.fungiblePrepareMintMutex.RLock()
	defer fake.fungiblePrepareMintMutex.RUnlock()
	fake.fungiblePrepareTransferMutex.RLock()
	defer fake.fungiblePrepareTransferMutex.RUnlock()
	fake.fungibleSubmitTxMutex.RLock()
	defer fake.fungibleSubmitTxMutex.RUnlock()
	fake.getAnnotationMutex.RLock()
	defer fake.getAnnotationMutex.RUnlock()
	fake.getAnnotationsByFilterMutex.RLock()
	defer fake.getAnnotationsByFilterMutex.RUnlock()
	fake.getStatusMutex.RLock()
	defer fake.getStatusMutex.RUnlock()
	fake.getTokenMutex.RLock()
	defer fake.getTokenMutex.RUnlock()
	fake.getTokenTypeMutex.RLock()
	defer fake.getTokenTypeMutex.RUnlock()
	fake.getTokenTypesMutex.RLock()
	defer fake.getTokenTypesMutex.RUnlock()
	fake.getTokensByFilterMutex.RLock()
	defer fake.getTokensByFilterMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.prepareMintMutex.RLock()
	defer fake.prepareMintMutex.RUnlock()
	fake.prepareRegisterMutex.RLock()
	defer fake.prepareRegisterMutex.RUnlock()
	fake.prepareTransferMutex.RLock()
	defer fake.prepareTransferMutex.RUnlock()
	fake.prepareUpdateMutex.RLock()
	defer fake.prepareUpdateMutex.RUnlock()
	fake.removeUserMutex.RLock()
	defer fake.removeUserMutex.RUnlock()
	fake.submitTxMutex.RLock()
	defer fake.submitTxMutex.RUnlock()
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Operations) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tokens.Operations = new(Operations)
